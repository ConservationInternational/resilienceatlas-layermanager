!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("axios"),require("lodash/compact"),require("lodash/isEmpty"),require("lodash/isEqual")):"function"==typeof define&&define.amd?define(["axios","lodash/compact","lodash/isEmpty","lodash/isEqual"],t):(e="undefined"!=typeof globalThis?globalThis:e||self).LayerManager=t(e.axios,e.compact,e.isEmpty,e.isEqual)}(this,function(e,t,r,s){"use strict";function i(e,t,r){return(t=function(e){var t=function(e,t){if("object"!=typeof e||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var s=r.call(e,t);if("object"!=typeof s)return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==typeof t?t:t+""}(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),r.push.apply(r,s)}return r}function n(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach(function(t){i(e,t,r[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))})}return e}const a={"Content-Type":"application/json"},c=(t,r={})=>e.get(t,n({headers:a},r)),h=(e,t={})=>{let r=e;return Object.keys(t).forEach(e=>{r=r.replace(new RegExp(`{{${e}}}`,"g"),t[e]).replace(new RegExp(`{${e}}`,"g"),t[e])}),r},l=(e,r={})=>{let s,i=e;return Object.keys(r).forEach(e=>{s=`${t(Object.keys(r[e]).map(t=>{const s=r[e][t];if(Array.isArray(s)&&s.length){return`${t} IN (${s.map(e=>"number"!=typeof e?`'${e}'`:e).join(", ")})`}return!Array.isArray(s)&&s?"number"!=typeof s?`${t} = '${s}'`:`${t} = ${s}`:null})).join(" AND ")}`,s=s&&e.startsWith("where")?`WHERE ${s}`:s&&e.startsWith("and")?`AND ${s}`:"",i=i.replace(new RegExp(`{{${e}}}`,"g"),s),i=i.replace(new RegExp(`{${e}}`,"g"),s)}),i},d=(e,t={},r={})=>{let s=e;return"string"==typeof s&&(s=h(s,t),s=l(s,r)),s},p=Symbol("CANCELED"),{L:u}="undefined"!=typeof window?window:{},y=t=>{if(!u)throw new Error("Leaflet must be defined.");const{layerConfig:r,params:s,sqlParams:i,interactivity:o}=t;return!1===r.parse||JSON.parse(d(JSON.stringify(r),s,i)),new Promise((r,s)=>{(t=>{const{layerConfig:r,params:s,sqlParams:i,interactivity:o}=t,a=!1===r.parse?r:JSON.parse(d(JSON.stringify(r),s,i)),h=JSON.stringify({version:"1.3.0",stat_tag:"API",layers:a.body.layers.map(e=>o&&o.length?n(n({},e),{},{options:n(n({},e.options),{},{interactivity:o.split(", ")})}):e)}),l=`?stat_tag=API&config=${encodeURIComponent(h)}`,u=`https://${a.account}-cdn.resilienceatlas.org/user/ra/api/v1/map${l}`,{layerRequest:y}=t;y&&y.cancel("Operation canceled by the user.");const f=e.CancelToken.source();return t.set("layerRequest",f),c(u,{cancelToken:f.token}).then(e=>e.status>400?(console.error(e),!1):e.data).catch(t=>{if(e.isCancel(t))return p;throw t})})(t).then(e=>{if(e===p)return;const s=`https://${e.cdn_url.https}/ra/api/v1/map/${e.layergroupid}/{z}/{x}/{y}.png`,i=u.tileLayer(s);if(o&&o.length){const s=`https://${e.cdn_url.https}/ra/api/v1/map/${e.layergroupid}/0/{z}/{x}/{y}.grid.json`,o=u.utfGrid(s),n=u.LayerGroup.extend({group:!0,setOpacity:e=>{t.mapLayer.getLayers().forEach(t=>{t.setOpacity(e)})}});return r(new n([i,o]))}return r(i)}).catch(e=>s(e))})};y.getBounds=t=>{if(!u)throw new Error("Leaflet must be defined.");return new Promise((r,s)=>{(t=>{const{layerConfig:r,params:s,sqlParams:i,type:o}=t;let{sql:n}=t;"raster"===o&&(n=`SELECT ST_Union(ST_Transform(ST_Envelope(the_raster_webmercator), 4326)) as the_geom FROM (${n}) as t`);const a=`\n    SELECT ST_XMin(ST_Extent(the_geom)) as minx,\n    ST_YMin(ST_Extent(the_geom)) as miny,\n    ST_XMax(ST_Extent(the_geom)) as maxx,\n    ST_YMax(ST_Extent(the_geom)) as maxy\n    from (${n}) as subq\n  `,h=`https://${(!1===r.parse?r:JSON.parse(d(JSON.stringify(r),s,i))).account}-cdn.resilienceatlas.org/user/ra/api/v2/sql?q=${a.replace(/\n/g," ")}`,{boundsRequest:l}=t;l&&l.cancel("Operation canceled by the user.");const u=e.CancelToken.source();return t.set("boundsRequest",u),c(h,{cancelToken:u.token}).then(e=>e.status>400?(console.error(e),!1):e.data).catch(t=>{if(e.isCancel(t))return p;throw t})})(t).then(e=>{if(e===p)return;const{maxy:t,maxx:s,miny:i,minx:o}=e.rows[0];return r([[t,s],[i,o]])}).catch(s)})};const{L:f}="undefined"!=typeof window?window:{},m=f&&f.GridLayer.extend({tiles:{},createTile({x:e,y:t,z:r},s){const{params:i}=this.options,o=d(i.url,n({x:e,y:t,z:r},i)),a=Object.keys(this.tiles);for(let e=0;e<a.length;e++)this.tiles[a[e]].z!==r&&delete this.tiles[a[e]];this.done=s;const c=f.DomUtil.create("canvas","leaflet-tile"),h=c.getContext("2d"),l=this.getTileSize();return c.width=l.x,c.height=l.y,this.getTile({x:e,y:t,z:r}).then(i=>{this.cacheTile(n({id:o,tile:c,ctx:h,image:i},{x:e,y:t,z:r})),this.drawCanvas(o),s(null,c)}).catch(e=>{s(e,c)}),c},getTile({x:e,y:t,z:r}){const{params:s,sqlParams:i}=this.options,{url:o,dataMaxZoom:a=20}=s,c=r-a,h=d(s.url,n({x:e,y:t,z:r},s));let l={x:e,y:t,z:r};c>0&&(l={x:Math.floor(e/2**c),y:Math.floor(t/2**c),z:a});const p=d(o,n(n({},l),s),i);return new Promise((e,t)=>{this.tiles[h]&&e(this.tiles[h].image);const r=new XMLHttpRequest;r.addEventListener("load",r=>{const{response:s}=r.currentTarget,i=URL.createObjectURL(s),o=new Image;o.src=i,o.onload=()=>{o.crossOrigin="",e(o),URL.revokeObjectURL(i)},o.onerror=()=>{t(new Error("Can't load image"))}}),r.addEventListener("error",t),r.open("GET",p,!0),r.responseType="blob",r.send()})},cacheTile(e){this.tiles[e.id]=n(n({},this.tiles[e.id]),e)},drawCanvas(e){"use asm";if(!this.tiles[e]){return}const{tile:t,ctx:r,image:s,x:i,y:o,z:n}=this.tiles[e];if(!t||!r||!s||typeof i==="undefined"||typeof o==="undefined"||typeof n==="undefined"){delete this.tiles[e];return}const{params:a,decodeParams:c,decodeFunction:h}=this.options;const{dataMaxZoom:l=20}=a;const d=n-l;r.clearRect(0,0,t.width,t.width);if(d<0){r.drawImage(s,0,0)}else{r.imageSmoothingEnabled=false;r.mozImageSmoothingEnabled=false;const e=t.width/2**d*(i%2**d)||0;const n=t.height/2**d*(o%2**d)||0;const a=t.width/2**d||0;const c=t.height/2**d||0;r.drawImage(s,e,n,a,c,0,0,t.width,t.height)}const p=r.getImageData(0,0,t.width,t.height);if(typeof h==="function"){h(p.data,t.width,t.height,n,c)}r.putImageData(p,0,0)},reDraw(e){this.options.params=e.params,this.options.sqlParams=e.sqlParams,this.options.decodeParams=e.decodeParams;const{params:t,sqlParams:r}=e;t&&t.url&&Object.keys(this.tiles).map(e=>{const{x:s,y:i,z:o}=this.tiles[e],a=d(t.url,n(n({x:s,y:i,z:o},t),{},{sqlParams:r}));return this.drawCanvas(a)})}}),g=Symbol("CANCELED"),w=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];class b{static from(e){if(!(e instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[t,r]=new Uint8Array(e,0,2);if(0xdb!==t)throw new Error("Data does not appear to be in a KDBush format.");const s=r>>4;if(1!==s)throw new Error(`Got v${s} data when expected v1.`);const i=w[0x0f&r];if(!i)throw new Error("Unrecognized array type.");const[o]=new Uint16Array(e,2,1),[n]=new Uint32Array(e,4,1);return new b(n,o,i,e)}constructor(e,t=64,r=Float64Array,s){if(isNaN(e)||e<0)throw new Error(`Unpexpected numItems value: ${e}.`);this.numItems=+e,this.nodeSize=Math.min(Math.max(+t,2),65535),this.ArrayType=r,this.IndexArrayType=e<65536?Uint16Array:Uint32Array;const i=w.indexOf(this.ArrayType),o=2*e*this.ArrayType.BYTES_PER_ELEMENT,n=e*this.IndexArrayType.BYTES_PER_ELEMENT,a=(8-n%8)%8;if(i<0)throw new Error(`Unexpected typed array class: ${r}.`);s&&s instanceof ArrayBuffer?(this.data=s,this.ids=new this.IndexArrayType(this.data,8,e),this.coords=new this.ArrayType(this.data,8+n+a,2*e),this._pos=2*e,this._finished=!0):(this.data=new ArrayBuffer(8+o+n+a),this.ids=new this.IndexArrayType(this.data,8,e),this.coords=new this.ArrayType(this.data,8+n+a,2*e),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([0xdb,16+i]),new Uint16Array(this.data,2,1)[0]=t,new Uint32Array(this.data,4,1)[0]=e)}add(e,t){const r=this._pos>>1;return this.ids[r]=r,this.coords[this._pos++]=e,this.coords[this._pos++]=t,r}finish(){const e=this._pos>>1;if(e!==this.numItems)throw new Error(`Added ${e} items when expected ${this.numItems}.`);return v(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(e,t,r,s){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:i,coords:o,nodeSize:n}=this,a=[0,i.length-1,0],c=[];for(;a.length;){const h=a.pop()||0,l=a.pop()||0,d=a.pop()||0;if(l-d<=n){for(let n=d;n<=l;n++){const a=o[2*n],h=o[2*n+1];a>=e&&a<=r&&h>=t&&h<=s&&c.push(i[n])}continue}const p=d+l>>1,u=o[2*p],y=o[2*p+1];u>=e&&u<=r&&y>=t&&y<=s&&c.push(i[p]),(0===h?e<=u:t<=y)&&(a.push(d),a.push(p-1),a.push(1-h)),(0===h?r>=u:s>=y)&&(a.push(p+1),a.push(l),a.push(1-h))}return c}within(e,t,r){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:s,coords:i,nodeSize:o}=this,n=[0,s.length-1,0],a=[],c=r*r;for(;n.length;){const h=n.pop()||0,l=n.pop()||0,d=n.pop()||0;if(l-d<=o){for(let r=d;r<=l;r++)O(i[2*r],i[2*r+1],e,t)<=c&&a.push(s[r]);continue}const p=d+l>>1,u=i[2*p],y=i[2*p+1];O(u,y,e,t)<=c&&a.push(s[p]),(0===h?e-r<=u:t-r<=y)&&(n.push(d),n.push(p-1),n.push(1-h)),(0===h?e+r>=u:t+r>=y)&&(n.push(p+1),n.push(l),n.push(1-h))}return a}}function v(e,t,r,s,i,o){if(i-s<=r)return;const n=s+i>>1;L(e,t,n,s,i,o),v(e,t,r,s,n-1,1-o),v(e,t,r,n+1,i,1-o)}function L(e,t,r,s,i,o){for(;i>s;){if(i-s>600){const n=i-s+1,a=r-s+1,c=Math.log(n),h=0.5*Math.exp(2*c/3),l=0.5*Math.sqrt(c*h*(n-h)/n)*(a-n/2<0?-1:1);L(e,t,r,Math.max(s,Math.floor(r-a*h/n+l)),Math.min(i,Math.floor(r+(n-a)*h/n+l)),o)}const n=t[2*r+o];let a=s,c=i;for(x(e,t,s,r),t[2*i+o]>n&&x(e,t,s,i);a<c;){for(x(e,t,a,c),a++,c--;t[2*a+o]<n;)a++;for(;t[2*c+o]>n;)c--}t[2*s+o]===n?x(e,t,s,c):(c++,x(e,t,c,i)),c<=r&&(s=c+1),r<=c&&(i=c-1)}}function x(e,t,r,s){E(e,r,s),E(t,2*r,2*s),E(t,2*r+1,2*s+1)}function E(e,t,r){const s=e[t];e[t]=e[r],e[r]=s}function O(e,t,r,s){const i=e-r,o=t-s;return i*i+o*o}const _={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:e=>e},P=Math.fround||(S=new Float32Array(1),e=>(S[0]=+e,S[0]));var S;class T{constructor(e){this.options=Object.assign(Object.create(_),e),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(e){const{log:t,minZoom:r,maxZoom:s}=this.options;t&&console.time("total time");const i=`prepare ${e.length} points`;t&&console.time(i),this.points=e;const o=[];for(let t=0;t<e.length;t++){const r=e[t];if(!r.geometry)continue;const[s,i]=r.geometry.coordinates,n=P(I(s)),a=P(M(i));o.push(n,a,1/0,t,-1,1),this.options.reduce&&o.push(0)}let n=this.trees[s+1]=this._createTree(o);t&&console.timeEnd(i);for(let e=s;e>=r;e--){const r=+Date.now();n=this.trees[e]=this._createTree(this._cluster(n,e)),t&&console.log("z%d: %d clusters in %dms",e,n.numItems,+Date.now()-r)}return t&&console.timeEnd("total time"),this}getClusters(e,t){let r=((e[0]+180)%360+360)%360-180;const s=Math.max(-90,Math.min(90,e[1]));let i=180===e[2]?180:((e[2]+180)%360+360)%360-180;const o=Math.max(-90,Math.min(90,e[3]));if(e[2]-e[0]>=360)r=-180,i=180;else if(r>i){const e=this.getClusters([r,s,180,o],t),n=this.getClusters([-180,s,i,o],t);return e.concat(n)}const n=this.trees[this._limitZoom(t)],a=n.range(I(r),M(o),I(i),M(s)),c=n.data,h=[];for(const e of a){const t=this.stride*e;h.push(c[t+5]>1?A(c,t,this.clusterProps):this.points[c[t+3]])}return h}getChildren(e){const t=this._getOriginId(e),r=this._getOriginZoom(e),s="No cluster with the specified id.",i=this.trees[r];if(!i)throw new Error(s);const o=i.data;if(t*this.stride>=o.length)throw new Error(s);const n=this.options.radius/(this.options.extent*Math.pow(2,r-1)),a=o[t*this.stride],c=o[t*this.stride+1],h=i.within(a,c,n),l=[];for(const t of h){const r=t*this.stride;o[r+4]===e&&l.push(o[r+5]>1?A(o,r,this.clusterProps):this.points[o[r+3]])}if(0===l.length)throw new Error(s);return l}getLeaves(e,t,r){t=t||10,r=r||0;const s=[];return this._appendLeaves(s,e,t,r,0),s}getTile(e,t,r){const s=this.trees[this._limitZoom(e)],i=Math.pow(2,e),{extent:o,radius:n}=this.options,a=n/o,c=(r-a)/i,h=(r+1+a)/i,l={features:[]};return this._addTileFeatures(s.range((t-a)/i,c,(t+1+a)/i,h),s.data,t,r,i,l),0===t&&this._addTileFeatures(s.range(1-a/i,c,1,h),s.data,i,r,i,l),t===i-1&&this._addTileFeatures(s.range(0,c,a/i,h),s.data,-1,r,i,l),l.features.length?l:null}getClusterExpansionZoom(e){let t=this._getOriginZoom(e)-1;for(;t<=this.options.maxZoom;){const r=this.getChildren(e);if(t++,1!==r.length)break;e=r[0].properties.cluster_id}return t}_appendLeaves(e,t,r,s,i){const o=this.getChildren(t);for(const t of o){const o=t.properties;if(o&&o.cluster?i+o.point_count<=s?i+=o.point_count:i=this._appendLeaves(e,o.cluster_id,r,s,i):i<s?i++:e.push(t),e.length===r)break}return i}_createTree(e){const t=new b(e.length/this.stride|0,this.options.nodeSize,Float32Array);for(let r=0;r<e.length;r+=this.stride)t.add(e[r],e[r+1]);return t.finish(),t.data=e,t}_addTileFeatures(e,t,r,s,i,o){for(const n of e){const e=n*this.stride,a=t[e+5]>1;let c,h,l;if(a)c=C(t,e,this.clusterProps),h=t[e],l=t[e+1];else{const r=this.points[t[e+3]];c=r.properties;const[s,i]=r.geometry.coordinates;h=I(s),l=M(i)}const d={type:1,geometry:[[Math.round(this.options.extent*(h*i-r)),Math.round(this.options.extent*(l*i-s))]],tags:c};let p;p=a||this.options.generateId?t[e+3]:this.points[t[e+3]].id,void 0!==p&&(d.id=p),o.features.push(d)}}_limitZoom(e){return Math.max(this.options.minZoom,Math.min(Math.floor(+e),this.options.maxZoom+1))}_cluster(e,t){const{radius:r,extent:s,reduce:i,minPoints:o}=this.options,n=r/(s*Math.pow(2,t)),a=e.data,c=[],h=this.stride;for(let r=0;r<a.length;r+=h){if(a[r+2]<=t)continue;a[r+2]=t;const s=a[r],l=a[r+1],d=e.within(a[r],a[r+1],n),p=a[r+5];let u=p;for(const e of d){const r=e*h;a[r+2]>t&&(u+=a[r+5])}if(u>p&&u>=o){let e,o=s*p,n=l*p,y=-1;const f=(r/h<<5)+(t+1)+this.points.length;for(const s of d){const c=s*h;if(a[c+2]<=t)continue;a[c+2]=t;const l=a[c+5];o+=a[c]*l,n+=a[c+1]*l,a[c+4]=f,i&&(e||(e=this._map(a,r,!0),y=this.clusterProps.length,this.clusterProps.push(e)),i(e,this._map(a,c)))}a[r+4]=f,c.push(o/u,n/u,1/0,f,-1,u),i&&c.push(y)}else{for(let e=0;e<h;e++)c.push(a[r+e]);if(u>1)for(const e of d){const r=e*h;if(!(a[r+2]<=t)){a[r+2]=t;for(let e=0;e<h;e++)c.push(a[r+e])}}}}return c}_getOriginId(e){return e-this.points.length>>5}_getOriginZoom(e){return(e-this.points.length)%32}_map(e,t,r){if(e[t+5]>1){const s=this.clusterProps[e[t+6]];return r?Object.assign({},s):s}const s=this.points[e[t+3]].properties,i=this.options.map(s);return r&&i===s?Object.assign({},i):i}}function A(e,t,r){return{type:"Feature",id:e[t+3],properties:C(e,t,r),geometry:{type:"Point",coordinates:[(s=e[t],360*(s-0.5)),q(e[t+1])]}};var s}function C(e,t,r){const s=e[t+5],i=s>=10000?`${Math.round(s/1000)}k`:s>=1000?Math.round(s/100)/10+"k":s,o=e[t+6],n=-1===o?{}:Object.assign({},r[o]);return Object.assign(n,{cluster:!0,cluster_id:e[t+3],point_count:s,point_count_abbreviated:i})}function I(e){return e/360+0.5}function M(e){const t=Math.sin(e*Math.PI/180),r=0.5-0.25*Math.log((1+t)/(1-t))/Math.PI;return r<0?0:r>1?1:r}function q(e){const t=(180-360*e)*Math.PI/180;return 360*Math.atan(Math.exp(t))/Math.PI-90}const{L:$}="undefined"!=typeof window?window:{},j={50:25,100:30,1e3:40},k=$&&$.GeoJSON.extend({initialize(t){const r=this;$.GeoJSON.prototype.initialize.call(this,[]);const{layerConfig:s,events:i,decodeClusters:o}=t;if(!o)return void console.warn("You must provide a decodeClusters function");const{html:a,sizes:h=j,clusterIcon:l,icon:d}=t.layerConfig||{};$.Util.setOptions(this,{pointToLayer(e,t){if(!(e.properties&&e.properties.cluster))return $.marker(t,{icon:$.icon(n({iconSize:[35,35]},d))});const r=e.properties.point_count;let s=null;if("function"==typeof h)s=()=>h(r);else{const e=Object.keys(h).find(e=>r<=parseInt(e,10)),t=h[e];s=$.point(t,t)}return $.marker(t,{icon:$.divIcon(n({iconSize:s,html:a&&"function"==typeof a?a(e):`<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; ${l.color?`background-color: ${l.color};`:""}">${e.properties.point_count_abbreviated}</div>`},l))})},onEachFeature(e,t){e.properties&&e.properties.cluster?t.on({click:()=>r.setMapView(e)}):i&&t.on(Object.keys(i).reduce((t,r)=>n(n({},t),{},{[r]:t=>i[r](n(n({},t),{},{data:e.properties}))}),{}))}});const{clusterConfig:p}=s||{};this.supercluster=T(n({radius:80,maxZoom:16},p)),(t=>{const{layerConfig:r,layerRequest:s}=t,{url:i}=r.body;s&&s.cancel("Operation canceled by the user.");const o=e.CancelToken.source();return t.set("layerRequest",o),c(i,{cancelToken:o.token}).then(e=>e.status>400?(console.error(e),!1):e.data).catch(t=>{if(e.isCancel(t))return g;throw t})})(t).then(e=>{if(e===g)return;const t=o(e);this.supercluster.load(t),this.update()})},setMapView(e){const t=e.geometry.coordinates,r=this.supercluster.getClusterExpansionZoom(e.properties.cluster_id);this._map.setView(t.reverse(),r)},onAdd(e){$.GeoJSON.prototype.onAdd.call(this,e),e.on("moveend zoomend",this.onMove,this)},onRemove(e){e.off("moveend zoomend",this.onMove,this),this.clear()},onMove(){this.clear(),this.update()},update(){const e=this._map.getZoom(),t=this._map.getBounds(),r=[t._southWest.lng,t._southWest.lat,t._northEast.lng,t._northEast.lat],s=this.supercluster.getClusters(r,e);this.addData(s)},clear(){$.GeoJSON.prototype.clearLayers.call(this,[])}}),{L:z}="undefined"!=typeof window?window:{},N=z&&z.GridLayer.extend({tiles:{},cache:{},mouseOn:null,createTile({z:e}){const t=Object.keys(this.tiles);for(let r=0;r<t.length;r++)this.tiles[t[r]].z!==e&&delete this.tiles[t[r]];const r=z.DomUtil.create("div","leaflet-tile"),s=this.getTileSize();return r.width=s.x,r.height=s.y,r},onAdd(e){z.GridLayer.prototype.onAdd.call(this,e),this.map=e;const t=Math.round(this.map.getZoom());t>this.options.maxZoom||t<this.options.minZoom||(e.on("click",this.click,this),e.on("mousemove",this.move,this))},onRemove(){const{map:e}=this;e.off("click",this.click,this),e.off("mousemove",this.move,this)},click(e){this.fire("click",this.objectForEvent(e))},move(e){const t=this.objectForEvent(e);t.data!==this.mouseOn?(this.mouseOn&&this.fire("mouseout",{latlng:e.latlng,data:this.mouseOn}),t.data&&this.fire("mouseover",t),this.mouseOn=t.data):t.data&&this.fire("mousemove",t)},objectForEvent:e=>z.extend({latlng:e.latlng,data:null},e)}),{L:D}="undefined"!=typeof window?window:{},R=eval,Z=e=>{if(!D)throw new Error("Leaflet must be defined.");const{layerConfig:t,params:r,sqlParams:s,decodeParams:i,interactivity:o}=e;let a;const c=!1===t.parse?t:JSON.parse(d(JSON.stringify(t),r,s));switch(c.body.crs&&D.CRS[c.body.crs]&&(c.body.crs=D.CRS[c.body.crs.replace(":","")],c.body.pane="tilePane"),c.type){case"wms":a=D.tileLayer.wms(c.url||c.body.url,c.body);break;case"tileLayer":if(JSON.stringify(c.body).indexOf('style: "function')>=0&&(c.body.style=R(`(${c.body.style})`)),a=i&&c.canvas?new m(n({},e)):D.tileLayer(c.url||c.body.url,c.body),o){const t=new N,r=D.LayerGroup.extend({group:!0,setOpacity:t=>{e.mapLayer.getLayers().forEach(e=>{e.setOpacity(t)})}});a=new r([a,t])}break;case"cluster":JSON.stringify(c.body).indexOf('style: "function')>=0&&(c.body.style=R(`(${c.body.style})`)),a=new k(e);break;default:a=D[c.type](c.body,c.options||{})}return new Promise((e,t)=>{a?e(a):t(new Error('"type" specified in layer spec doesn`t exist'))})};Z.getBounds=e=>{if(!D)throw new Error("Leaflet must be defined.");const{layerConfig:t,params:r,sqlParams:s}=e,i=!1===t.parse?t:JSON.parse(d(JSON.stringify(t),r,s)),{bbox:o}=i;return new Promise(e=>{if(o){e([[o[1],o[0]],[o[3],o[2]]])}else e(null)})};const{L:B}="undefined"!=typeof window?window:{},U=eval,J=e=>{if(!B)throw new Error("Leaflet must be defined.");if(!B.esri)throw new Error("To support this layer you should add esri library for Leaflet.");const{layerConfig:t,interactivity:r,params:s,sqlParams:i}=e,o=!1===t.parse?t:JSON.parse(d(JSON.stringify(t),s,i)),a=JSON.stringify(o.body||{}).replace(/"mosaic-rule":/g,'"mosaicRule":').replace(/"mosaic_rule":/g,'"mosaicRule":').replace(/"use-cors":/g,'"useCors":').replace(/"use_cors":/g,'"useCors":');return B[o.type]?new Z(n({},e)):new Promise((t,s)=>{if(!B.esri[o.type])return s(new Error('"type" specified in layer spec doesn`t exist'));const i=JSON.parse(a);let n;if(i.pane="tilePane",i.useCors=!0,i.style&&i.style.indexOf("function")>=0&&(i.style=U(`(${i.style})`)),n=B.esri[o.type](i),!n)return s();if(n.on("load",()=>{n.setZIndex(e.zIndex)}),n.on("requesterror",e=>console.error(e)),n.setZIndex||(n.setZIndex=e=>{n._currentImage&&(n._currentImage._image.style.zIndex=e)}),r){const t=new N,r=B.LayerGroup.extend({group:!0,setOpacity:t=>{e.mapLayer.getLayers().forEach(e=>{e.setOpacity(t)})}});n=new r([n,t])}return t(n)})},{L:F}="undefined"!=typeof window?window:{},G=e=>{if(!F)throw new Error("Leaflet must be defined.");const{id:t,layerConfig:r,interactivity:s,params:i,sqlParams:o,decodeParams:a}=e,c=`https://api.resourcewatch.org/v1/layer/${t}/tile/gee/{z}/{x}/{y}`,h=!1===r.parse?r:JSON.parse(d(JSON.stringify(r),i,o));let l;if("tileLayer"===h.type)l=a?new m(n({},e)):F.tileLayer(c,h.body);else l=F.tileLayer(c,h.body);if(s){const t=new N,r=F.LayerGroup.extend({group:!0,setOpacity:t=>{e.mapLayer.getLayers().forEach(e=>{e.setOpacity(t)})}});l=new r([l,t])}return new Promise((e,t)=>{l?e(l):t(new Error('"type" specified in layer spec doesn`t exist'))})},{L:V}="undefined"!=typeof window?window:{},W=V&&new V.LatLngBounds(new V.LatLng(49.4966745,-66.357422),new V.LatLng(24.6070691,-131.660156)),Y=e=>{const{id:t,layerConfig:r,interactivity:s}=e,{period:i}=r,o=(i||{}).value||"1971",a=`https://api.resourcewatch.org/v1/layer/${t}/tile/loca/{z}/{x}/{y}?year=${new Date(o).toISOString()}`;let c=V.tileLayer(a,n(n({},r.body),{},{minNativeZoom:4,bounds:W}));if(s){const t=new N,r=V.LayerGroup.extend({group:!0,setOpacity:t=>{e.mapLayer.getLayers().forEach(e=>{e.setOpacity(t)})}});c=new r([c,t])}return new Promise(e=>{e(c)})},{L:X}="undefined"!=typeof window?window:{},H=e=>{const{id:t,layerConfig:r,interactivity:s}=e,{period:i}=r,o=(i||{}).value||"1971-01-01",n=`https://api.resourcewatch.org/v1/layer/${t}/tile/nexgddp/{z}/{x}/{y}?year=${new Date(o).toISOString()}`;let a=X.tileLayer(n,r.body);if(s){const t=new N,r=X.LayerGroup.extend({group:!0,setOpacity:t=>{e.mapLayer.getLayers().forEach(e=>{e.setOpacity(t)})}});a=new r([a,t])}return new Promise(e=>{e(a)})};class K{constructor(e={}){i(this,"opacity",1),i(this,"visibility",!0),Object.assign(this,e,{changedAttributes:{}})}get(e){return this[e]}set(e,t){return this[e]=t,this}update(e){const t=n({},this),r=n({},e);this.set("changedAttributes",{}),Object.keys(r).forEach(e=>{s(t[e],r[e])||(this.changedAttributes[e]=r[e],this.set(e,r[e]))})}}class Q{constructor(e,t,r={}){var s;this.map=e,this.plugin=new t(this.map),(s=this.plugin)&&["add","remove","setVisibility","setOpacity","setEvents","setZIndex","setLayerConfig","setParams","setDecodeParams","getLayerByProvider"].forEach(e=>{s[e]||console.error(`The ${e} function is required for layer manager plugins`)}),this.layers=[],this.promises={},this.pendingRequests={},this.failedLayers={},this.onLayerError=r.onLayerError||null}renderLayers(){return this.layers.length>0?(this.layers.forEach(e=>{const{changedAttributes:t}=e,{sqlParams:r,params:s,layerConfig:i}=t,o=Object.keys(t).length>0,n=r||s||i;if(!e.mapLayer||o){if(e.mapLayer&&o&&!n)return this.updateLayer(e),void e.set("changedAttributes",{});e.mapLayer&&n&&this.updateLayer(e),e.mapLayer||this.pendingRequests[e.id]||this.failedLayers[e.id]||(this.requestLayer(e),this.requestLayerBounds(e)),e.set("changedAttributes",{})}}),0===Object.keys(this.promises).length?Promise.resolve(this.layers):Promise.all(Object.values(this.promises)).then(()=>this.layers).then(()=>{this.promises={}}).catch(e=>(console.error("[LayerManager] Error in renderLayers:",e),this.promises={},this.layers))):Promise.resolve(this.layers)}add(e,t={opacity:1,visibility:!0,zIndex:0,interactivity:null}){return void 0===e?(console.error("layers is required"),this):Array.isArray(e)?(e.forEach(e=>{const r=this.layers.find(t=>t.id===e.id),s=n(n({},e),t);r?r.update(s):this.layers.push(new K(s))}),this.layers):(console.error("layers should be an array"),this)}updateLayer(e){const{opacity:t,visibility:s,zIndex:i,params:o,sqlParams:n,decodeParams:a,layerConfig:c,events:h}=e.changedAttributes;void 0!==t&&this.plugin.setOpacity(e,t),void 0!==s&&this.plugin.setOpacity(e,s?e.opacity:0),void 0!==i&&this.plugin.setZIndex(e,i),void 0!==h&&this.setEvents(e),r(c)||this.plugin.setLayerConfig(e),r(o)||this.plugin.setParams(e),r(n)||this.plugin.setParams(e),r(a)||this.plugin.setDecodeParams(e)}remove(e){const t=this.layers.slice(0),r=Array.isArray(e)?e:[e];this.layers.forEach((e,s)=>{r?r.includes(e.id)&&(this.plugin.remove(e),t.splice(s,1)):this.plugin.remove(e)}),this.layers=r?t:[]}setOpacity(e,t){const r=this.layers.filter(t=>e.includes(t.id));r.length?r.forEach(e=>{this.plugin.setOpacity(e,t)}):console.error("Can't find the layer")}setVisibility(e,t){const r=this.layers.filter(t=>e.includes(t.id));r.length?r.forEach(e=>{this.plugin.setVisibility(e,t)}):console.error("Can't find the layer")}setZIndex(e,t){const r=this.layers.filter(t=>e.includes(t.id));r.length?r.forEach(e=>{this.plugin.setZIndex(e,t)}):console.error("Can't find the layer")}setEvents(e){const{events:t}=e;t&&this.plugin.setEvents(e)}fitMapToLayer(e){if("function"!=typeof this.plugin.fitMapToLayer)return void console.error("This plugin does not support fitting map bounds to layer yet.");const t=this.layers.find(t=>t.id===e);t&&this.plugin.fitMapToLayer(t)}requestLayer(e){const{provider:t}=e,r=this.plugin.getLayerByProvider(t);if(!r){const r=new Error(`${t} provider is not yet supported.`);return console.error(`Error loading layer ${e.id}:`,r),this.failedLayers[e.id]={error:r,timestamp:Date.now()},e.set("loadError",r),this.onLayerError&&this.onLayerError({layerId:e.id,layerName:e.name||e.id,error:r,timestamp:Date.now()}),!1}return this.pendingRequests[e.id]=!0,this.promises[e.id]=r.call(this,e).then(t=>{const r=t;e.set("mapLayer",r),delete this.pendingRequests[e.id],this.requestLayerSuccess(e),this.setEvents(e)}).catch(t=>{delete this.pendingRequests[e.id],this.failedLayers[e.id]={error:t,timestamp:Date.now()},e.set("loadError",t),console.error(`Error loading layer ${e.id}:`,t),this.onLayerError&&this.onLayerError({layerId:e.id,layerName:e.name||e.id,errorType:"layer",errorDescription:"Failed to load layer data",provider:e.provider,url:t.config?.url||null,error:t,timestamp:Date.now()})}),this}requestLayerSuccess(e){this.plugin.add(e),this.plugin.setZIndex(e,e.zIndex),this.plugin.setOpacity(e,e.opacity),this.plugin.setVisibility(e,e.visibility)}requestLayerBounds(e){const{provider:t}=e,r=this.plugin.getLayerBoundsByProvider(t);if(!r)return!1;const s=`${e.id}_bounds`;return!this.pendingRequests[s]&&(this.pendingRequests[s]=!0,this.promises[s]=r.call(this,e).then(t=>{delete this.pendingRequests[s],e.set("mapLayerBounds",t)}).catch(t=>{delete this.pendingRequests[s],this.failedLayers[s]={error:t,timestamp:Date.now()},console.error(`Error loading bounds for layer ${e.id}:`,t),this.onLayerError&&this.onLayerError({layerId:e.id,layerName:e.name||e.id,errorType:"bounds",errorDescription:"Failed to load layer boundaries",provider:e.provider,url:t.config?.url||null,error:t,timestamp:Date.now()})}),this)}}return Q.PluginLeaflet=class{constructor(e){i(this,"events",{}),i(this,"method",{cartodb:y,carto:y,raster:y,arcgis:J,featureservice:J,mapservice:J,tileservice:J,esrifeatureservice:J,esrimapservice:J,esritileservice:J,gee:G,loca:Y,nexgddp:H,leaflet:Z,wms:Z}),i(this,"setEvents",e=>{const{mapLayer:t,events:r}=e;return"cluster"!==e.layerConfig.type&&(this.events[e.id]&&Object.keys(this.events[e.id]).forEach(e=>{t.group?t.eachLayer(t=>{t.off(e)}):t.off(e)}),Object.keys(r).forEach(e=>{t.group?t.eachLayer(t=>{t.on(e,r[e])}):t.on(e,r[e])}),this.events[e.id]=r),this}),i(this,"fitMapToLayer",e=>{const t=e.get("mapLayerBounds");t&&this.map.fitBounds(t)}),this.map=e}add(e){const{mapLayer:t}=e;this.map.addLayer(t)}remove(e){const{mapLayer:t,events:r}=e;r&&t&&Object.keys(r).forEach(e=>{t.group?t.eachLayer(t=>{t.off(e)}):t.off(e)}),t&&this.map.removeLayer(t)}getLayerByProvider(e){return this.method[e]}getLayerBoundsByProvider(e){return this.method[e].getBounds}setZIndex(e,t){const{mapLayer:r}=e;return r.setZIndex(t),this}setOpacity(e,t){const{mapLayer:r}=e;return"function"==typeof r.setOpacity&&r.setOpacity(t),"function"==typeof r.setStyle&&r.setStyle({opacity:t}),this}setVisibility(e,t){const{opacity:r}=e;this.setOpacity(e,t?r:0)}setParams(e){this.remove(e)}setLayerConfig(e){this.remove(e)}setDecodeParams(e){const{mapLayer:t,params:r,sqlParams:s,decodeParams:i,decodeFunction:o}=e;return t.group?t.eachLayer(e=>{e.reDraw&&e.reDraw({decodeParams:i,decodeFunction:o,params:r,sqlParams:s})}):t.reDraw({decodeParams:i,decodeFunction:o,params:r,sqlParams:s}),this}},Q.replace=d,Q.substitution=h,Q.concatenation=l,Q});
